# プログラミングI 第11回
正規表現

## 前回の課題

「映画の視聴記録から映画名と映画名の対に対するtanimoto係数を２段階のハッシュ表にするプログラム」の仕様について

1. このプログラムの全体の仕様である２段階ハッシュを作成する機能のテストデータとその望ましい計算結果を作成してください
2. このプログラムの部品機能であるtanimoto係数を計算するメソッドのテストデータとその望ましい計算結果を作成してください


また、その仕様に基づく機能を確認するために必要なテストデータとの結果を作成してください。


###  前回の課題への基本的アプローチ

* テストデータとその結果で仕様を定義する
* 映画名と映画名の対に対する２段階ハッシュの作成プログラムの仕様の定義
	* ２段階ハッシュの具体的な内容を構成する（３要素程度でよい）
	* テストデータの作成
	* ２段階ハッシュ表を作成するプログラムの作成
* 映画の間のtanimoto係数を計算するメソッドの仕様の定義
	* ２つの映画の視聴データ（数人分程度でよい）
	* 特徴的なテストデータで比較する
		* 完全に視聴履歴が一致している場合のtanimoto係数
		* 完全に視聴履歴が不一致の場合のtanimoto係数
		* 共通部分が部分的に存在するケースのtanimoto係数
		* tanimoto係数を計算するプログラムの作成
	* テストの実施

### 映画名と映画名の対に対する２段階ハッシュの作成プログラムの仕様の定義

* ２段階ハッシュの具体的な構成（３要素程度でよい）

#### 表としての表現

* 表の構造だけが目的
* 値はダミーでよい

||a|b|c|
|:--:|:--:|:--:|:--:|
|a|1.0| 1.0 | 1.0 |
|b| 1.0 | 1.0 | 1.0 |
|c| 1.0 | 1.0 | 1.0 |

#### 表の２段階ハッシュによる表現

値は適当なもの(1.0) を入れているが本質ではない

```ruby
# ２段階ハッシュ
# a の行
ha={"a"=> 1.0,"b"=> 1.0,"c"=> 1.0}
# b の行
hb={"a"=> 1.0,"b"=> 1.0,"c"=> 1.0}
# c の行
hc={"a"=> 1.0,"b"=> 1.0,"c"=> 1.0}
# a,b,c を列としてまとめる
h={"a"=>ha,"b"=>hb,"c"=>hc}
p h
```

#### プログラムの仕様=期待される結果

```ruby
spec={"a"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "b"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "c"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}}
```

#### テストデータ

映画名として "a" "b" "c" をインデックス0 に持つ配列で、データは入れていない

```ruby
test_data1=[["a"],["b"],["c"]]
```

#### ２段ハッシュで表を作成するプログラム

* 映画名の配列から２段ハッシュの表を作成する
* 値は適当なもの(1.0) を入れる

```ruby
# 表の１段目のハッシュ（メモ変数）の初期化
table={}
# 表の１段目のイテレーション
test_data1.each do |x|
	# 表の２段目のハッシュの初期化
	table[x[0]]={}
	# 表の２段目のイテレーション
	testdata.each do |y|
		# 表の２段目の作成、値は1.0 にしている
		table[x[0]][y[0]]=1.0
	end
end
実行結果を確認する
p table
```

#### 期待される結果（仕様）とテストの実行結果の比較

仕様

```ruby
p spec

{"a"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "b"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "c"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}}
```

実行結果

```ruby
p table

{"a"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "b"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}, "c"=>{"a"=>1.0, "b"=>1.0, "c"=>1.0}}
```

比較

```ruby
table==spec

true
```

期待どおりのプログラムになっている

### tanimoto係数

#### テストデータ

* 完全に一致している
　	→　1.0
* 完全に不一致
	→  	0.0
* 集合の要素数が4+4で共通集合が3 の場合
	→ 	3/(8-3)=0.6
* 集合の要素数が4+4で共通集合が1の場合
	→ 	1/(8-1)=1/7=0.14285714285714285

```ruby
t1=["a", 1,1,1,1,0,0,0,0]
t2=["b", 0,0,0,0,1,1,1,1]
t3=["c", 1,1,1,0,1,0,0,0]
```

####  tanimoto係数を計算するプログラム

```ruby
# 共通集合の数（[1,1]のときだけ１.0を合計する方法として1と0の積を利用）
def tanimoto(x,y)
	nxy=x.zip(y).reduce(0.0){|s,p|s+(p[0]*p[1])}
	return nxy/(x.sum+y.sum-nxy)
end
```

#### テスト結果

```ruby
# 完全一致
puts tanimoto(t1[1..-1],t1[1..-1])
# 完全不一致
puts tanimoto(t1[1..-1],t2[1..-1])
# 集合の要素数が4+4で共通集合が3 の場合
puts tanimoto(t1[1..-1],t3[1..-1])
# 集合の要素数が4+4で共通集合が1の場合
puts tanimoto(t2[1..-1],t3[1..-1])
```

```
1.0

0.0

0.6

0.14285714285714285
```

### 部品を組み合わせて全体を構成する

テストデータ

```ruby
t1=["a", 1,1,1,1,0,0,0,0]
t2=["b", 0,0,0,0,1,1,1,1]
t3=["c", 1,1,1,0,1,0,0,0]
test_data2=[t1,t2,t3]
```

プログラム

```ruby
# tanimoto係数メソッド
def tanimoto(x,y)
	nxy=x.zip(y).reduce(0.0){|s,p|s+(p[0]*p[1])}
	return nxy/(x.sum+y.sum-nxy)
end

# tanimoto係数の２段階ハッシュテーブル
def tanimoto_table(data)
	table={}
	data.each do |x|
		table[x[0]]={}
		data.each do |y|
			table[x[0]][y[0]]=tanimoto(x[1..-1],y[1..-1])
		end
	end
	return table
end

p tanimoto_table(test_data2)
```

#### 期待される結果の表による表現

||a|b|c|
|:--:|:--:|:--:|:--:|
|a|1.0| 0.0 | 0.6 |
|b| 0. 0| 1.0 | 0.14285714285714285 |
|c| 0.6 | 0.14285714285714285 | 1.0 |

#### 期待される結果（仕様）のハッシュ表現

```ruby
spec={"a"=>{"a"=>1.0, "b"=>0.0, "c"=>0.6}, "b"=>{"a"=>0.0, "b"=>1.0, "c"=>0.14285714285714285}, "c"=>{"a"=>0.6, "b"=>0.14285714285714285, "c"=>1.0}}
```

#### 実際の結果

```ruby
{"a"=>{"a"=>1.0, "b"=>0.0, "c"=>0.6}, "b"=>{"a"=>0.0, "b"=>1.0, "c"=>0.14285714285714285}, "c"=>{"a"=>0.6, "b"=>0.14285714285714285, "c"=>1.0}}
```

実際の結果と仕様の比較

```ruby
 tanimoto_table(test_data2)==spec
 
 true
```

## 正規表現

文字列のパターンを表現する方法

* 「メタ文字」: 文字のパターンを意味する文字
* 正規表現は、メタ文字を使って文字列のパターンを定義する


## 松岡修造風のより自然なメッセージ

最終的なメッセージの構造を壊さないようにするべき

```ruby
m="サバを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、
常にサバサバしているだろ。
サバは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
"

puts m.gsub(/サバ/,"イカ")
```

```
イカを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、
常にイカイカしているだろ。
イカは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
```

これは、「イカイカしているだろう」は、「イカしているだろう」にしたい

* gsub のメソッドチェーンで解決する方法

```ruby
puts m.gsub(/サバサバ/,"イカ").gsub(/サバ/,"イカ")
```

```
イカを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、常にイカしているだろ。
イカは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
```

## 正規表現とメタ文字

| メタ文字 | 説明 |
|:--:| :-- |
|*| 直前の文字の0回以上の繰り返し（最長一致）|
|+| 直前の文字の1回以上の繰り返し（最長一致）|
|*?| 直前の文字の0回以上の繰り返し（最短一致）|
|+?| 直前の文字の1回以上の繰り返し（最短一致）|
|{n}| 直前の文字のn回の繰り返し|
|{n,m}| 直前の文字のn回以上m回未満の繰り返し|
|?| 直前の文字は省略可能|

| メタ文字 | 説明 |
|:--:| :-- |
|.|任意の1文字|
|[]| カッコの中の文字のどれか1文字|
|[X-Y]| 文字の文字コード上の範囲|
|[^X]| カッコ内で指定した文字以外の文字(否定の^)|
| \| | 区切られたどれかの文字列とマッチする|
|^|	行の先頭|
|$|	行の末尾|
|()|	サブパターン、カッコ内のパターンにマッチした文字列を参照できる|

| メタ文字 | 説明 |
|:--:| :-- |
| \\ |エスケープ、直後の文字をメタ文字ではなく文字として扱う|
|\w|アルファベット、数字、アンダスコア（ _ ）のどれかの1文字|
|\d|数字1文字|

### 正規表現クラス (Regexp)

/abc/ は文字列(String)ではなく正規表現 (Regexp)というクラスのオブジェクトです

```ruby
p "abc".class
```

```ruby
String
```

```ruby
p /abc/.class
```

```ruby
Regexp
```

### 直前の文字の0回以上の繰り返し: *

直前の文字の0回以上の繰り返し

```ryby
p /Goo*gl/=~"Gogl"
p /Goo*gl/=~"Googl"
p /Goo*gl/=~"Gooooooogl"
```

```ruby
0
0
0
```

### 直前の文字の1回以上の繰り返し: +

直前の文字の1回以上の繰り返し

```ruby
p /Goo+gl/=~"Gogl"
p /Goo+gl/=~"Googl"
p /Goo+gl/=~"Gooooooogl"
```

```ruby
nil
0
0
```

### 直前の文字のn回の繰り返し: {n}

```ruby
p /a{8}/=~"aaa"
p /a{8}/=~"aaaaaaaa"
p /a{8}/=~"bbbaaaaaaaa"
```

```ruby
nil
0
3
```


### 直前の文字は省略可能: ?

直前の文字は省略可能

```ruby
p /Goo?gl/=~"Gogl"
p /Goo?gl/=~"Googl"
```

```ruby
0
0
```

これは直前１文字省略ではマッチできない

```ruby
p /Goo?gl/=~"Gooogl"
```

```ruby
nil
```

### 任意の1文字: .

```ruby
p /私は.です/=~"私は神です"
```
```ruby
0
```

これは２文字なのでマッチしない

```ruby
p /私は.です/=~"私は人間です"
```

```ruby
nil
```

任意の２文字の場合

```ruby
p /私は..です/=~"私は人間です"
```

```ruby
0
```

メタ文字 . の繰り返し

```ruby
p /私は.+です/=~"私はホモ・サピエンスです"
```

```ruby
0
```

### [] 中のどれか1文字

```ruby
p /私は[鰻肉鮨]を食べたい/=~"私は鰻を食べたい"
p /私は[鰻肉鮨]を食べたい/=~"私は肉を食べたい"
p /私は[鰻肉鮨]を食べたい/=~"私は鮨を食べたい"
```

```ruby
0
0
0
```

* これはマッチしない

```ruby
p /私は[鰻肉鮨]を食べたい/=~"私は米を食べたい"
```

```ruby
nil
```

### [^X]	カッコ内で指定した文字以外の文字(否定の^)

```ruby
p /私は[^鰻肉鮨]を食べたい/=~"私は米を食べたい"
```

```ruby
0
```

### | で区切られたどれかの文字列とマッチする

```ruby
p /ステーキ|寿司/=~"私はステーキを食べたい"
p /ステーキ|寿司/=~"私は寿司を食べたい"
```

```ruby
2
2
```

これはマッチしない

```ruby
p /ステーキ|寿司/=~"私はいくらを食べたい"
```

```ruby
nil
```

###  文字列の先頭のときだけマッチする: ^

```ruby
p /^カモシカ/ =~ "カモシカは鹿である"
```

```ruby
0
```

これは先頭でないのでマッチしない

```ruby
p /^カモシカ/ =~ "鹿もカモシカも鹿である"
```

```ruby
nil
```

### 文字列の末尾のときだけマッチする: $

```ruby
p /ですか$/ =~ "あなたは大学教授ですか"
```

```ruby
8
```


これは文字列の最後ではないのでマッチしない

```ruby
p /ですか$/ =~ "ああ大学教授ですか、ご愁傷さまです"
```

```ruby
nil
```

#### アルファベットn文字の繰り返し

```ruby
p /[a-z]{8}/=~"abdcjkljlkjg"
```

```
0
```

* \w: アルファベット、数字、アンダスコア（ _ ）のどれかの1文字
* \w を使って次のように書くこともできる

```ruby
p /\w{8}/=~"abdcjkljlkjg"
```

```
0
```

#### ８文字のアルファベットとマッチさせる方法

* このパターンは、8文字以上でもマッチしてしまう

```ruby
p /\w{8}/=~"abcdefghijklmn"
```

```
0
```

* ちょうど８文字でマッチするようにする
* 文字列の先頭と文字列の末尾の条件を入れてあげる

```ruby
p /^\w{8}$/=~"abcdefgh"
```

```
0
```

* 8文字以上の場合

```ruby
p /^\w{8}$/=~"abcdefghijklmn"
```

```
nil
```

* 8文字未満の場合

```ruby
p /^\w{8}$/=~"abc"
```

```
nil
```


### メタ文字のエスケープ

. などがメタ文字として認識されて、本来は排除したい文字列までマッチしてしまう

```ruby
p /www.kindai.ac.jp/=~"http://www=kindai-ac+jp"
```

```ruby
7
```

メタ文字の前に \  をつけるとメタ文字ではなくその文字そのものとして解釈される

```ruby
p /www\.kindai\.ac\.jp/=~"http://www=kindai-ac+jp"
p /www\.kindai\.ac\.jp/=~"http://www.kindai.ac.jp"
```

```ruby
nil
7
```

## 正規表現によるフォーマット検証メソッド

* 正規表現の結果はマッチング位置のインデックス
* Rubyの条件文は、nilを false nil以外をtrue として処理する

### 数字８文字の文字列であることを検証するメソッドの例

メタ文字 \d は数値１文字とマッチする
（数値が先頭で数値が終端となる６文字の文字列）

```ruby
def valid(s)
	if s=~/^\d{6}$/ then 
		return true 
	else 
		return false 
	end
end

puts valid("123456")
puts valid("12345")
puts valid("1234567")
```

```ruby
true
false
false
```




## 正規表現を利用した文字列処理

### 正規表現を利用した split

正規表現で文字列を分割する

* "ため"　という文字列で文字列を分割する例

```ruby
p "脳は成長するため喜ぶために壁にぶつかることを求めている".split(/ため/)
```

* "ため"という文字列が無くなっている

```ruby
["脳は成長する", "喜ぶ", "に壁にぶつかることを求めている"]
```
* splitメソッドは、正規表現の中でパターンを()で囲むと参照できるようになる

```ruby
p "脳は成長するため喜ぶために壁にぶつかることを求めている".split(/(ため)/)
```

* "ため"という文字列が区切りごとに参照されている

```ruby
["脳は成長する", "ため", "喜ぶ", "ため", "に壁にぶつかることを求めている"]
```

#### メタ文字を使ってパターンを利用してみる

#####「.+ため」という正規表現は、その前の文字列を含んだ最長パターンにマッチする

* . は１文字
* + は直前の文字の繰り返し（この場合はメタ文字の繰り返し）
* + はパターンを含む最長のものを見つける

```ruby
p "脳は成長するため喜ぶために壁にぶつかることを求めている".split(/(.+ため)/)
```

* パターンで区切っているので、先頭に "" （空の文字列）が出現している
* "脳は成長するため、喜ぶため"　の中には "ため"が２回出現しているが、最長の文字列とマッチするので、一つになっている

```ruby
["", "脳は成長するため喜ぶため", "に壁にぶつかることを求めている"]
```

#####「.+?ため」という正規表現は、その前の文字列を含んだ最短パターンにマッチする

```ruby
p "脳は成長するため喜ぶために壁にぶつかることを求めている".split(/(.+?ため)/)
```

```ruby
 ["", "脳は成長するため", "", "喜ぶため", "に壁にぶつかることを求めている"]
```

* 余計な "" をreject する

```ruby
p "脳は成長するため喜ぶために壁にぶつかることを求めている".split(/(.+?ため)/).reject{|x|x==""}
```

```ruby
["脳は成長するため", "喜ぶため", "に壁にぶつかることを求めている"]
```

## 正規表現を利用した gsub


* 置換えパターンに重複がある場合

```ruby
m="サバを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、
常にサバサバしているだろ。
サバは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
"

puts m.gsub(/サバ/,"イカ")
```

```
イカを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、
常にイカイカしているだろ。
イカは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
```

「イカイカしているだろう」は、「イカしているだろう」にしたい


* 正規表現で解決する方法
* これは (パターン)+ 記法を使うと　「サバ」　と　「サバサバ」　を一つのパターンにして、「イカ」に置き換えることができるので、次のように書くことができます
 
```ruby
puts m.gsub(/(サバ)+/,"イカ")
```

```
イカを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、
常にイカしているだろ。
イカは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
```

### 松岡修造風のより自然なメッセージの構成方法

次のメッセージは「自分らしく力を出し切れ」という松岡修造氏による応援のメッセージです。

このメッセージの 「噴水」を　「ドラゴン花火」、「シャワー」、「水鉄砲」などに置き換えてもメッセージの主旨はあまり変わらない

```ruby
m="
自分らしく生きられていないのか？
自分を出し切れていないのか？
噴水を見てみろよ。
噴水は、喜びも悲しみも、
楽しさも悔しさも、
すべてを一生懸命に出し切っている。
だから、あれほどキラキラと輝いているんだよ。
君も噴水になってみろよ。
一つの所に命を懸けて、
すべてを出し切ってみろ！
きっとキラッキラに輝けるぞ！
"

def shuzo(m)
	keyword=["ドラゴン花火","シャワー","水鉄砲"].shuffle[0]
	return m.gsub(/噴水/,keyword)
end

puts shuzo(m)
```

```
自分らしく生きられていないのか？
自分を出し切れていないのか？
水鉄砲を見てみろよ。
水鉄砲は、喜びも悲しみも、
楽しさも悔しさも、
すべてを一生懸命に出し切っている。
だから、あれほどキラキラと輝いているんだよ。
君も水鉄砲になってみろよ。
一つの所に命を懸けて、
すべてを出し切ってみろ！
きっとキラッキラに輝けるぞ！
```

##  課題

ユーザIDのフォーマットを、6文字のアルファベットと３桁の数字とします。

例："abcdef123"

入力したユーザIDの文字列がこのフォーマットであることを検証し、正しいフォーマットの場合に true そうでない場合に flase を返すメソッド valid_id を作成してください

