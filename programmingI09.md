# プログラミングI 第9回
文字列処理の基本

## 前回の課題

映画の視聴記録から２段階のハッシュ表を作成するプログラムを以下の方法で作成してください

* eachメソッドを使う方法
* for文を使う方法

作成した表を使って、以下の映画のそれぞれについて

類似度が高い順に５つ取り出し、さらにその５つの中から類似度が0.4に満たないものは reject メソッドを使って除いた結果を表示してください

* 未来のミライ
* バタフライ・エフェクト
* グレイテストショーマン
* フォレストガンプ
* シェイプオブウォーター
* アオハライド

###  前回への基本的アプローチ

* ２段ハッシュによる表を作成する
* ２段ハッシュを作成するために２段階のイテレータを利用する
* eachメソッドを使う場合は、行を作成するeachメソッドの中に列を作成するeachメソッドを埋め込む
* for文を使う場合は、行を作成するfor文の中に列を作成するfor文を埋め込む
* 作成したハッシュの表から指定した映画の行を取り出し、tanimoto係数に関してソート処理を行う
* ソートした結果のtanimoto係数が 0.4 に満たないものを除く

```ruby
# tanimoto係数
def tanimoto(a,b)
    na=a.sum                        # aの１の数
    nb=b.sum                        # bの１の数
    azb=a.zip(b)                    # aとbをzipした配列
    ab=azb.map{|x|if x==[1,1] then 1 else 0 end}
    nab=ab.sum                      # aとbの共通集合の数
    return nab/(na+nb-nab).to_f     # tanimoto係数
end
```

```ruby
# eachメソッドを使う場合
table={}
movies.each do |x|		  # 行のキー
	table[x[0]]={}			  # 映画名をキーとし値を{}にする
   movies.each do |y| 	  # 列のキー
		 table[x[0]][y[0]]=tanimoto(x[1..-1],y[1..-1])
   end
end
p table
```

```ruby
# for文を使う場合
table={}
for x in movies do		# 行のキー
    table[x[0]]={}		# 映画名をキーとし値を{}にする
    for y in movies do	# 列のキー
        table[x[0]][y[0]]=tanimoto(x[1..-1],y[1..-1])
    end
end
p table
```

```ruby
 [["言の葉の庭", 0.4117647058823529]]
 [["きっと、うまくいく", 0.6666666666666666], ["セブン", 0.6666666666666666], ["英国王のスピーチ", 0.5]]
 [["舟を編む", 0.5555555555555556], ["ピンポン", 0.45454545454545453], ["シェイプオブウォーター", 0.42857142857142855]]
 [["セブン", 0.6666666666666666], ["きっと、うまくいく", 0.6666666666666666], ["シンドラーのリスト", 0.5]]
 [["はじまりのうた", 0.6666666666666666], ["舟を編む", 0.42857142857142855], ["グレイテストショーマン", 0.42857142857142855]]
[]
```

## サンプルデータ（松岡修造のメッセージ）

[https://github.com/ShigeichiroYamasaki/programming-I/blob/master/shuzo.rb](https://github.com/ShigeichiroYamasaki/programming-I/blob/master/shuzo.rb)

```ruby
message=[
"自分らしく生きられていないのか？
自分を出し切れていないのか？
噴水を見てみろよ。
噴水は、喜びも悲しみも、
楽しさも悔しさも、
すべてを一生懸命に出し切っている。
だから、あれほどキラキラと輝いているんだよ。
君も噴水になってみろよ。
一つの所に命を懸けて、
すべてを出し切ってみろ！
きっとキラッキラに輝けるぞ！
",
"高い壁にぶつかって、
「できない」「やめたい」なんて思っているのか？
でも、君の脳は「ＮＯ！」なんて言ってないはず。
むしろ、全力で君を信じ、応援してくれているんだ。
人間の脳は、困難な場面を乗り越えた時、
強い快感を覚え、その喜びで成長すると言われている。
脳は成長するため、喜ぶために壁にぶつかることを求めているんだよ。
君なら必ず、その壁を乗り越えられる！
君の脳も、僕も、そう信じているんだ。
",
"僕の大好きな富士山、
本当に美しいよね。
だけど、富士山も自分の力だけで美しくなったわけじゃない。
いつまでも美しくあってほしい、
輝いていてほしい、
そんなふうに自分を愛してくれる人たちの思いを、
富士山は全力で受け止め、
自分のパワーに変えてきた、
だから、あれほど美しい姿になったんだ。
君も、周りにいる人たちの思いを感じてみないか。
そうすればきっと、君も富士山になれるよ。
",
"ゾウはあれほど体が大きいのに、
器用に動かせるのは長い鼻だけ。
でも、ゾウはできないことを嘆くのではなく、
長い鼻だけでできることを一所懸命考え、
徹底的に磨き上げた。
本気で努力したいからこそ、食事や水浴び、
何でもできるようになったんだ。
今は気がつかなくても、
君にも必ず一つ、
君だけにしかできないことがあるんだ。
それが見つかったら、迷わずゾウになれ！
僕もなるよ、松岡修ゾウに。
そして、君を全力で応援する！
",
"頑張っているのに、誰もほめてくれない、
なんてクヨクヨ悩んでいるのか？
だったら、マツタケを見てみろよ。
マツタケは枯れ葉の陰に隠れて育つから、
普段は誰にも気づかれない。
それでも、雨や風に耐えながら、
ひとり静かに頑張っている。
だから、誰にも真似できないほどの味や香りをまとい、
たくさんの人から「おいしいね」ってほめられるんだ。
君も必ずなれるよ、
とびっきりおいしいマツタケに！
",
"君はいつも、本当に頑張っているよね。
でも、時には思い切って休むことも大切だよ。
君を照らしてくれる太陽だって、
四六時中、輝いているわけじゃない、
水平線の向こうに沈んだ後は、
ゆっくり体を休めて、力を備えている、
だからこそ、次の日の朝、
元気な姿で昇ってくることができるんだ。
ここ一番の場面で力を発揮するためにも、
時には「休む勇気」を持つことも大切なんだ。
",
"いろんな絵の具を混ぜ合わせると、最後は黒になる。
同じにように、心の中でいろんな感情が混ざり合うと、
心はどんどん黒に近づいていく。
そんな時、僕は心の中にある洗濯機を回すんだ。
スイッチを入れ、グルグルと感情が回り始めると、
次第にイヤな気持ちが洗い流されて、
最後は真っ白でキレイな気持ちだけが残る。
何かに悩んでいるのなら、心の洗濯機を回すんだ！
",
"仕事、家事、勉強、スポーツ、習い事・・・、
何でも「基本」が大切だと言われているよね。
僕は基本を学び、
それを積み重ねていけば、
必ず本気になれると信じている。
信じられない？
それなら、基本って１０回言ってごらん、
キホンキホンキホンキホンキホン
キホンキホンキホンキホンキホンキ、
ほら、基本を積み重ねていけば、
本気になれるんだ。
そして、その経験はいつか必ず、
君を助ける力になってくれるよ。
",
"温泉に入ると、心も体も癒されて、
笑顔になれるよね。
でも、温泉が「俺を癒してくれ！」なんて、
見返りを求めてきたことあるかな？
僕たちは人に何かをした時、
つい見返りを求めてしまう、
与えた以上の見返りを期待することもある。
本当のやさしさって、
温泉のようなものじゃないかな。
ただ、相手が笑顔になってくれること、
それが最高の見返りだと思うんだ。
",
"山々を染める紅葉を見て、
「私もあんなふうに美しく輝きたい」
なんて思っていないか？
自然の紅葉は一年に一度しか輝かない、
でも、僕の心は春夏秋冬、常に紅葉している。
なぜなら、ポジティブな言葉で自分を前向きにしているから、
失敗を恐れず、何かにチャレンジしているから。
そうすると、
心が高揚して、美しく輝けるんだ。
大丈夫、君も心もきっと紅葉できる。
",
"最近、自我が強くなっていないか？
雪ダルマは、吹雪の中でも身動きひとつとれない、
春が来れば、いやおうなしに溶かされてしまう。
そんな雪ダルマが、文句を言ったことがあるか？
自己中心的な雪ダルマ、見たことがあるか？
誰かを楽しませるために、
自我を捨て、じっとたたずんでいるだろ、
だから、光輝いているんだよ。
時には自我を捨て、雪ダルマになることも大切なんだ。
",
"何となく周りに流されてしまう自分がイヤで、ネチネチ悩んでいるのか？
サバを見てみろよ、
いろいろな魚が泳いでいる所でも、周りを気にせず、常にサバサバしているだろ。
サバは「自分」を持っている、
常に自分の心に耳を傾け、自分で考え決断し、行動しているんだよ。
自分を持つことができれば、周りの声や視線など気にならず、
いつも自分らしくいられるんだ。
"
]

```

## サンプルデータの確認

```ruby
puts message[0]
```

結果

```ruby
自分らしく生きられていないのか？
自分を出し切れていないのか？
噴水を見てみよ。
噴水は、喜びも悲しみも、
楽しさも悔しさも、
すべてを一生懸命に出し切っている。
だから、あれほど
キラキラと輝いているんでよ。
君も噴水になってみろよ。
一つの所に命を懸けて、
すべてを出し切ってみろ！
きっとキラッキラに輝けるぞ！
```

```ruby
puts message[1]
puts message[2]
puts message[3]
```

### randomメソッド

0から n-1 までの範囲の乱数を出力する

```ruby
puts rand(6)
puts rand(6)
puts rand(6)
```

## ランダムにメッセージをつぶやくメソッド

```ruby
# 松岡修造ボット
def shuzo(m)    # メッセージのデータを入力mとする
    return m[rand(m.size)]
end

puts shuzo(message)
```

## 文字列処理の基本

### 文字列の連結する：+

```ruby
puts "わたし"+"まけましたわ"

name="松岡修"
puts "ぼくも"+name+"ゾウになる！"
```

### 文字列を繰り返す：*

```ruby
puts "キホン"*10
```

```ruby
puts "キホン"*10+"キ"
```

```ruby
puts "■"*10
puts "■"*3
puts "■"*5
puts "■"*6
```

```ruby
■■■■■■■■■■
■■■
■■■■■
■■■■■■
```

### 文字列の配列を連結する： joinメソッド

```ruby
m= ["東京", "特許", "許可局"].join
puts m
```

 文字を加えて文字列の配列を連結する： joinメソッド

```ruby
m=["東京", "特許", "許可局"].join('、')
puts m
```

### サンプルメッセージを一つの文字列に連結

```ruby
all_sentences=message.join
p all_sentences
```

### 文字列を特定文字で分割：splitメソッド

```ruby
p "九州、四国、中国、近畿、中部、関東".split("、")
```

### 松岡修造の全メッセージを "。" で分割する

```ruby
sentences=all_sentences.split("。")

puts sentences[0]
puts sentences[1]
puts sentences[2]
```

### 松岡修造の全メッセージを "\n" （改行記号）で分割する

改行が出てくるたびに分割するので、さらに細かい文の断片になる

```ruby
sentences2=all_sentences.split("\n")

puts sentences2[0]
puts sentences2[1]
puts sentences2[2]

puts sentences2.size
```

### 配列の撹拌 : shuffleメソッド

```ruby
p [1,2,3,4].shuffle
p ["a", "b", "c", "d"].shuffle
```

### ランダムな松岡修造風メッセージを生成する

断片的な文を撹拌して先頭から３つつなげる

```ruby
puts sentences.shuffle[0..2].join
```

文の断片を撹拌して改行をつけて5つつなげる

```ruby
puts sentences2.shuffle[0..4].join("\n")
```

### 同一の文字列を比較：==

```ruby
p "abc" == "abc"
p "abc" == "acb"
```
### 文字列のインデックス

文字列は、配列のように扱うことができる

```ruby
puts "しかもかもしかもしかである"[0]
puts "しかもかもしかもしかである"[1]
puts "しかもかもしかもしかである"[2]
puts "しかもかもしかもしかである"[3]
```

### インデックスによる文字列要素への代入

```ruby
m="しかもかもしかもしかである"
m[2]="と"
puts m
```

### 文字列の文字数を得るメソッド

```ruby
puts "しかもかもしかもしかである".size
```

### 文字列の部分を範囲で取り出す

```ruby
puts "しかもかもしかもしかである"[3..6]
```
## 文字列のパターンと正規表現

正規表現とは文字列のパターンを表現する方法

### 正規表現と文字列の一致の例

```ruby
p /しか/ =~ "しかもかもしかもしかである"
```

インデックス０の位置でパターンが一致する

```ruby
0
```

```ruby
p /かもしか/ =~ "しかもかもしかもしかである"
```

インデックス３の位置でパターンが一致する

```ruby
3
```

```ruby
p /もしも/ =~ "しかもかもしかもしかである"
```

どこにもパターンが一致しない

```ruby
nil
```

### nil とは？

nilは対象が存在しないという意味

条件文では、真偽値の false と同じ意味を持つ
条件文で、nil以外の値は true と同じ意味を持つ

```ruby
if nil then
    puts 'トゥルー'
else
    puts 'フォールス'
end
```
`
 /もしも/ =~ "しかもかもしかもしかである"
`
の評価結果はnil なので

```ruby
if /もしも/ =~ "しかもかもしかもしかである" then
    puts 'トゥルー'
else
    puts 'フォールス'
end
```

### 条件文の真偽値としての nil 以外の値

nil以外の値（数値など）は真偽値の true と同じ意味を持つ

```ruby
if /しか/ =~ "しかもかもしかもしかである" then
    puts 'トゥルー'
else
    puts 'フォールス'
end
```
### 複数のパターンで比較する

/パターン１|パターン２|...|パターンn/

* みろよ。
* から、
* ない。

を含むパターンのときに「トゥルー」そうなでいとき「フォールス」となるメソッド

```ruby
def miroyokaranai(m)
	if m =~ /みろよ。|から、|ない。/ then
    		puts 'トゥルー'
	else
    		puts 'フォールス'
	end
end

miroyokaranai("マツタケを見てみろよ。")
```

```ruby
miroyokaranai("マツタケは枯れ葉の陰に隠れて育つから、")
```

```ruby
miroyokaranai("普段は誰にも気づかれない。")
```

```ruby
miroyokaranai("輝いていてほしい、")
```

### gsubメソッド

文字列の部分を全て置き換えるメソッド

```ruby
puts "しかもかもしかもしかである".gsub(/しか/,"鹿")
```

### 文字列を置き換える順序による違い

```ruby
m="しかしあしかはしかでない"
m=m.gsub(/しか/,"鹿")
m=m.gsub(/あしか/,"アシカ")
m=m.gsub(/しかし/,"然し")
puts m
```

```ruby
m="しかしあしかはしかでない"
m=m.gsub(/あしか/,"アシカ")
m=m.gsub(/しかし/,"然し")
m=m.gsub(/しか/,"鹿")
puts m
```
### メソッドチェーン

オブジェクト.メソッド.メソッド. ... . メソッド

```ruby
puts "かもしか".gsub(/しか/,"鹿")
puts "かもしか".gsub(/しか/,"鹿").gsub(/かも/,"鴨")
```

### selectメソッドを使った文字列の選択

松岡修造のメッセージの細かい文字列の断片の配列 sentence2 から一定のパターンの文字列を選択する

```ruby
miroyo=sentences2.select{|x|x=~/みろよ。/}
p miroyo
dayo=sentences2.select{|x|x=~/だよ。/}
p dayo
noka=sentences2.select{|x|x=~/のか？/}
p noka
runda=sentences2.select{|x|x=~/るんだ。/}
p runda
saba=sentences2.select{|x|x=~/サバ/}
p saba
```

### rejectメソッドを使った文字列の選択

```ruby
msg=sentences2.reject do |x|
		x=~/のか？|るんだ。|みろよ。/
         end.shuffle[0..3].join("\n")
```

### より松岡修造らしいメッセージの構成


1. 〜のか？
2. 〜みろよ
3. 〜だよ
3. 〜るんだ

```ruby
def shuzo(ss)
	noka=ss.select{|x|x=~/のか？/}.shuffle[0]
	miroyo=ss.select{|x|x=~/みろよ。/}.shuffle[0]
	dayo=ss.select{|x|x=~/だよ。/}.shuffle[0]
	msg=ss.reject do |x|
		x=~/のか？|るんだ。|みろよ。/
      end.shuffle[0..3].join("\n")
	runda=ss.select{|x|x=~/るんだ。/}.shuffle[0]
	return [noka, miroyo, dayo, msg, runda].join("\n")
end

puts shuzo(sentences2)
```

## 課題

松岡修造のメッセージの細かい文字列の断片の配列 sentence2 を利用して
ランダムでできるだけ自然な内容をにつぶやく shuzo メソッドを作成してください

* 自分でselectメソッドやrejectメソッドを使って、文の生成に適したパターンを見つけてください
* 生成するメッセージの構成順序を考えて、より自然な文章にしてください



